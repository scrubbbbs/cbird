/* Command-line interface
   Copyright (C) 2021 scrubbbbs
   Contact: screubbbebs@gemeaile.com =~ s/e//g
   Project: https://github.com/scrubbbbs/cbird

   This file is part of cbird.

   cbird is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   cbird is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with cbird; if not, see
   <https://www.gnu.org/licenses/>.  */

#include "cimgops.h"
#include "commands.h"
#include "cpu.h"
#include "database.h"
#include "dctvideoindex.h" // MAX_VIDEOS, MAX_IMAGES_PER_VIDEO
#include "engine.h"
#include "env.h"
#include "git.h" // generated by tools/gitversion.sh
#include "gui/cropwidget.h"
#include "gui/mediabrowser.h"
#include "gui/theme.h"
#include "gui/videocomparewidget.h"
#include "hamm.h"
#include "ioutil.h"
#include "media.h"
#include "opencv2/core.hpp"
#include "qtutil.h"
#include "scanner.h"

static QStringList buildFlags() {
  QStringList flags;
#if defined(__clang__)
  flags += "clang v" __clang_version__;
#elif defined(__GNUC__)
  flags += "gcc v" __VERSION__;
#else
  flags += "unknown compiler v" __VERSION__;
#endif
#ifdef __OPTIMIZE__
  flags += "optimize";
#endif
#ifdef DEBUG
  flags += "debug";
#endif
#ifdef __x86_64__
  flags += "x86_64";
#endif
#ifdef __SSE2__
  flags += "sse2";
#endif
#ifdef __SSSE3__
  flags += "ssse3";
#endif
#ifdef __FMA__
  flags += "fma";
#endif
#ifdef __SSE4_1__
  flags += "sse4_1";
#endif
#ifdef __SSE4_2__
  flags += "sse4_2";
#endif
#ifdef __POPCNT__
  flags += "popcnt";
#endif
#ifdef __AVX__
  flags += "avx";
#endif
#ifdef __AVX2__
  flags += "avx2";
#endif
#ifdef __AVX512F__
  flags += "avx512f";
#endif

  return flags;
}

static void printLicense() {
  qFlushMessageLog();
  QFile file(qq(":res/license.txt"));
  file.open(QFile::ReadOnly);
  printf("%s", file.readAll().data());
}

static int printUsage(int argc, char** argv) {
  (void)argc;

  QFile file(qq(":res/usage.txt"));
  file.open(QFile::ReadOnly);
  const QString usage = file.readAll();

  QString paramsUsage;

  auto formatParams = [](const Params& params) {
    QString lines;
    for (auto& key : params.keys()) {
      auto v = params.getValue(key);
      lines += QString("\n    %1 %2 %3 [%4]")
                   .arg(key, -8)
                   .arg(QString("<") + v.typeName() + ">", -8)
                   .arg(v.label)
                   .arg(v.toString());
      const auto& nv = v.namedValues();
      if (nv.count() > 0)
        for (auto& n : nv)
          lines +=
              QString("\n      %1 (%2) %3").arg(n.shortName, -6).arg(n.value).arg(n.description);
    }
    return lines;
  };

  auto formatProps = []() {
    QString lines;
    for (const auto& p : Media::propertyList()) {
      lines += QString("%1 - %2\n      ").arg(p.first, -27).arg(p.second);
    }
    return lines;
  };

  auto str = usage.arg(argv[0])
                 .arg(formatParams(SearchParams()))
                 .arg(formatParams(IndexParams()))
                 .arg(formatProps());
  printf("%s\n", qUtf8Printable(str));
  return 0;
}

/// print command line completions (e.g. for bash), pipe (|) separated
/// see install() for enabling in bash
int printCompletions(const char* argv0, const QStringList& args) {
  if (args.count() < 3) {
    printf(
        "completions require $CWORD as 2nd argument\nusage:%s -complete $CWORD "
        "[args]\n",
        argv0);
    exit(0);
  }

  // clang-format off
  QSet<QString> cmds{/* no arguments */
                     "-update", "-headless", "-dups", "-similar", "-select-none", "-select-all",
                     "-select-errors", "-first", "-chop", "-first-sibling", "-sort-similar",
                     "-remove", "-nuke", "-rename", "-sets", "-folders", "-exit-on-select", "-show",
                     "-help", "-version", "-about", "-verify", "-vacuum", "-select-result",
                     "-license", "-cwd", "-init", "-list-search-params", "-list-index-params",
                     "-weeds", /*"-track-weeds",*/ "-nuke-weeds", "-dump", "-list-formats",
                     "-focus-first", "-no-delete", "-v", "-verbose", "-q", "-quiet", "-list-codecs",
                     "-migrate",
										 /* one argument */
                     "-select-id", "-select-sql", "-max-per-page", "-head", "-tail", "-theme"};
  // clang-format on
  const QSet<QString> twoArg{"-rename", "-compare-videos", "-merge", "-video-thumbnail"};
  cmds += twoArg;

  const QSet<QString> typeArg{"-select-type"};
  cmds += typeArg;

  const QSet<QString> propArg{"-sort", "-sort-rev", "-group-by", "-with", "-without", "-or-with",
                              "-or-without", "-sort-result", "-sort-result-rev"};
  cmds += propArg;

  const QSet<QString> fileArg{"-select-one",     "-jpeg-repair-script", "-test-csv",
                              "-test-video-decoder", "-compare-videos",
                              "-test-image-loader",  "-video-thumbnail"};
  cmds += fileArg;

  const QSet<QString> dirArg{"-use", "-dups-in", "-nuke-dups-in", "-similar-in", "-move"};
  cmds += dirArg;

  const QSet<QString> fileOrDirArg{"-similar-to", "-select-path", "-select-files", "-merge", "-select-grid"};
  cmds += fileOrDirArg;

  const SearchParams searchParams;
  QSet<QString> searchParamArg;
  const auto sk = searchParams.keys();
  for (auto& k : sk) searchParamArg << ("-p." + k);
  cmds += searchParamArg;

  const IndexParams indexParams;
  QSet<QString> indexParamArg;
  const auto ik = indexParams.keys();
  for (auto& k : ik) indexParamArg << ("-i." + k);
  cmds += indexParamArg;

  // cword is the $CWORD variable in bash... index of the cursor (in words)
  int cword = args.at(2).toInt() + 3;

  // completions must write to stdout so we cannot log there
#if DEBUG_COMPLETIONS
  QFile log(QDir::tempPath() + "/cbird-completions.log");
  Q_ASSERT(log.open(QFile::WriteOnly | QFile::Append));
#else
  QString log;
#endif

  QDebug debug(&log);
  debug << args << "\n";

  QStringList completions;

  // current and previous "words"/args
  const QString curr = cword >= args.count() ? "" : args[cword];
  const QString prev = cword > 4 && args.count() > 4 ? args[cword - 1] : "";
  const QString prev1 = cword > 5 && args.count() > 5 ? args[cword - 2] : "";

  debug << "curr:" << curr << "prev:" << prev << "prev1:" << prev1 << "\n";

  auto completePath = [&](const QDir::Filters& filter) {
    // FIXME: does not work if path contains a space
    QString path = curr;
    path.replace("\\", "");  // remove shell escape so QFileInfo works
    path = path.trimmed();

    // bool quote = false; // remove leading quote, in which case we do not escape output
    if (path.startsWith("\"") || path.startsWith("\'")) {
      //  quote = true;
      path = path.mid(1);
    }
    const QString homePath = QDir::homePath();
    const bool isHome = path.startsWith("~");
    if (isHome) path = homePath + path.mid(1);  // QFileInfo doesn't recognize ~

    const QFileInfo info(path);
    const QDir dir = info.dir();  // dir we are going to list for completions

    // prefix for dir entries so completion is (prefix + "/" + entry)
    QString prefix = dir.path();
    if (!info.isRelative()) prefix = dir.absolutePath();
    if (isHome) prefix = "~" + prefix.mid(homePath.length());  // keep ~ when matching

    if (!prefix.endsWith("/")) prefix += "/";  // some rare cases do not need / added, like "/"

    debug << "prefix" << prefix << "\n";
    debug << "isDir" << info.isDir() << path << dir.exists() << "\n";
    debug << "isFile" << info.isFile() << "\n";

    const auto entries = dir.entryInfoList(filter | QDir::Dirs | QDir::NoDotAndDotDot);
    for (auto& e : entries) {  // match curr to name
      QString comp = prefix + e.fileName();
      // if (!quote) comp = comp.replace(" ", "\\ ");
      // if (!(filter & QDir::Dirs) && e.isDir()) comp += "/";
      if (isHome && path.startsWith(homePath)) path = "~" + path.mid(homePath.length());
      debug << "check-prefix" << path << comp << "\n";
      if (comp.startsWith(path)) completions << comp;
    }
  };

  auto completeParam = [&](const Params& params) {
    auto key = prev.mid(prev.indexOf('.') + 1);
    auto v = params.getValue(key);
    const auto& nv = v.namedValues();
    for (auto& n : nv) {
      const QLatin1String str(n.shortName);
      if (curr.isEmpty() || str.startsWith(curr)) completions << n.shortName;
    }
    if (v.type == Params::Value::Bool) {
      const QStringList sym{"true", "false", "0", "1"};
      for (auto& s : sym)
        if (curr.isEmpty() || s.startsWith(curr)) completions << s;
    }
  };

  auto completeType = [&]() {
    const QStringList sym{"1", "2", "3", "i", "v", "a"};
    for (auto& s : sym)
      if (curr.isEmpty() || s.startsWith(curr)) completions << s;
  };

  auto completeProp = [&]() {
    static constexpr struct {
      const char *prop, *propHash, *tagFile;
    } metaTags[4] = {{"exif", "exif#", ":res/exif.txt"}, // FIXME: xmp tags
                     {"iptc", "iptc#", ":res/iptc.txt"},
                     {"ffmeta", "ffmeta#", ":res/ffmeta.txt"},
                     {"text", "text#", ":res/textkeys.txt"}};

    for (const auto& p : Media::propertyList()) {
      QString sym(p.first);
      for (const auto& m : metaTags)
        if (sym.startsWith(m.prop)) {
          sym = m.propHash;
          break;
        }
      if (curr.isEmpty() || sym.startsWith(curr)) completions << sym;
    }
    if (curr.isEmpty()) return;
    for (const auto& m : metaTags)
      if (curr.startsWith(m.propHash)) {
        QFile tagFile(m.tagFile);
        Q_ASSERT(tagFile.open(QFile::ReadOnly));
        const auto tags = tagFile.readAll().split('\n');
        for (const auto& tag : tags) {
          QString sym = m.propHash + tag;
          if (sym.startsWith(curr)) completions << sym;
        }
        return;
      }
  };

  if (curr.startsWith("-")) {
    for (auto& cmd : cmds)
      if (cmd.startsWith(curr)) completions << cmd;
  } else {
    QString cmd = prev;
    if (twoArg.contains(prev1)) cmd = prev1;

    if (fileOrDirArg.contains(cmd)) {
      completePath(QDir::Files | QDir::Dirs);
    } else if (dirArg.contains(cmd)) {
      completePath(QDir::Dirs);
    } else if (fileArg.contains(cmd)) {
      completePath(QDir::Files);
    } else if (searchParamArg.contains(cmd)) {
      completeParam(searchParams);
    } else if (indexParamArg.contains(cmd)) {
      completeParam(indexParams);
    } else if (typeArg.contains(cmd)) {
      completeType();
    } else if (propArg.contains(cmd)) {
      completeProp();
    }
  }

  for (auto& c : completions) debug << "output:" << c << "\n";

  printf("%s\n", qUtf8Printable(completions.join("|")));
  return 0;
}

static char inputChar(char defaultOption) {
  fflush(stdout);
  fflush(stdin);
  char ch = 0, option = defaultOption;

  // non-newline, valid option
  if (1 == scanf("%c", &ch) && ch != 10) option = ch;

  // no input
  if (ch == 0) exit(-1);

  // non-newline, eat anything else until the newline
  if (ch != 10)
    while (1 == scanf("%c", &ch) && ch != 10)
      ;

  return option;
}

#ifndef Q_OS_WIN

static void installCompletions(const char* name, const char* file, const char* script) {
  printf("install: You seem to be using %s, install completions in ~/%s? [y/N]: ", name, file);
  char ch = inputChar('N');
  if ((ch == 'Y' || ch == 'y')) {
    QFile bashrc(QDir::home().filePath(file));
    if (!bashrc.exists()) {
      printf("install: ~/%s does not exist\n", file);
      return;
    }

    if (bashrc.copy(bashrc.fileName() + ".bak"))
      printf("install: ~/%s backed up\n", file);
    else
      printf("install: ~/%s was not backed up: %s\n", file, qUtf8Printable(bashrc.errorString()));

    Q_ASSERT(bashrc.open(QFile::ReadOnly));
    QString bashContents = bashrc.readAll();
    bashrc.close();

    const QStringList lines = bashContents.split('\n');
    QStringList newLines;
    bool dropLine = false;
    bool inserted = false;
    for (auto& line : lines) {
      if (line.contains("<cbird-completions>")) {
        dropLine = true;
        continue;
      }
      if (line.contains("</cbird-completions>")) {
        dropLine = false;
        inserted = true;
        newLines += script;
        continue;
      }
      if (!dropLine) newLines += line;
    }

    QString newContents = newLines.join('\n');
    if (!inserted) newContents += QString("\n\n") + script + "\n\n";

    Q_ASSERT(bashrc.open(QFile::WriteOnly));
    bashrc.write(newContents.toUtf8());
    printf("install: ~/%s updated, run \"source ~/%s\" or start a new shell\n", file, file);
  }
}

static void install(const QString& argv0, const QString& prefix) {
  QFileInfo dir(prefix);
  if (!dir.isDir()) {
    printf("install: %s is not a directory\n", qUtf8Printable(prefix));
    return;
  }

  const char* bashCompletionScript =
      R"bash(##### <cbird-completions> #####
function _cbird {
  OIFS=$IFS
  IFS='|'
  COMPREPLY=()
  for word in $(cbird -complete $COMP_CWORD ${COMP_WORDS[*]}); do
    COMPREPLY+=( "$word" )
    if [[ "$word" == *"#" ]]; then # no space after hash
      compopt -o nospace
    fi
  done
  IFS=$OIFS
}
complete -o filenames -F _cbird cbird
##### </cbird-completions> #####)bash";

  const char* zshCompletionScript =
      R"zsh(##### <cbird-completions> #####
_cbird_completion() {
  local curword=$((CURRENT - 1))
  local word="${words[CURRENT]}"
  local output=$(cbird -complete "$curword" "${words[@]}")
  local completions=(${(s[|])output})

  for comp in "${completions[@]}"; do
    if [[ "$word" =~ "^[']" ]]; then
      comp=("${comp//'/'\''}") # starts with ', escape '
    elif [[ "$word" =~ "^[\"]" ]]; then
      comp=("${comp//\"/\\\"}") # starts with ", escape "
    elif [[ "$comp" =~ "[ \"'<>=\?\*\;]" ]]; then
      comp=("${(q)comp}") # escape unquoted stuff
    fi

    if [[ "$comp" =~ "#$" ]]; then
      compadd -Q -S '' --  "$comp" # no space after #
    else
      compadd -Q -- "$comp"
    fi
  done
}
compdef _cbird_completion cbird
##### </cbird-completions> #####)zsh";

  printf("install: Install cbird into %s ? [y/N]: ", qUtf8Printable(prefix));
  char ch = inputChar('N');
  if (ch == 'Y' || ch == 'y') {
    QString sudo;
    if (!dir.isWritable() || !dir.isExecutable()) {
      Q_ASSERT(0 == system("sudo -k"));  // force re-entering password
      fprintf(stdout, "install: Permission required for %s\n", qUtf8Printable(prefix));
      if (0 != system("sudo echo 'install: Authenticated'")) return;
      sudo = "sudo ";
    }

    QVector<QStringList> binaries{{"cbird", argv0}};

    // we can run these from within the appimage now
    //    const QString appDir = getenv("APPDIR");
    //    if (!appDir.isEmpty()) {
    //      binaries.append({"ffplay-sbs", appDir+"/cbird/bin/ffplay-sbs"});
    //      binaries.append({"ff-compare-audio", appDir+"/cbird/bin/ff-compare-audio"});
    //    }

    for (auto& binary : qAsConst(binaries)) {
      QString cmd = QString("%1install -D -v \"%2\" \"%3/bin/%4\"")
                        .arg(sudo)
                        .arg(binary[1])
                        .arg(prefix)
                        .arg(binary[0]);
      qDebug() << cmd;
      qFlushMessageLog();
      if (0 != system(qUtf8Printable(cmd)))
        printf("install: installation of %s failed\n", qPrintable(binary[0]));
    }
  }

  if (0 != system("cbird -version >/dev/null 2>&1"))
    printf("install: cbird doesn't seem to be in your PATH, bash completions cannot work\n");
  if (0 != system("trash-put --version >/dev/null 2>&1"))
    printf("install: trash-cli is not installed, required for file deletion\n");

  // this is bundled now
  // if (0 != system("ffplay -version >/dev/null 2>&1"))
  //  printf("install: ffplay is not installed, recommended for video compare tool\n");

  // $SHELL is only for the login shell; ps T will detect any process in this terminal
  bool isBash = 0 == system("x=$(ps -T); echo $x | grep -q bash");
  bool isZsh = 0 == system("x=$(ps -T); echo $x | grep -q zsh");

  if (isBash) installCompletions("bash", ".bashrc", bashCompletionScript);
  if (isZsh) installCompletions("zsh", ".zshrc", zshCompletionScript);
}
#endif  // !Q_OS_WIN

// globals for lazy init
static bool checkIndexPathExists = true;

static QString& indexPath() {
  static auto* s = new QString;
  return *s;
}

static Engine* _engine = nullptr;

Engine& engine() {
  QDir dir(indexPath());
  if (!_engine && checkIndexPathExists && !dir.exists(INDEX_DIRNAME)) {
    qFlushMessageLog();
    printf(
        "cbird: No index found. Pass -use <dir> to a valid location,\n"
        "       or pass -create/-update to skip this prompt.\n\n");
    printf("cbird: Create index in {%s} ? [Y/n] : ", qUtf8Printable(dir.absolutePath()));
    char choice = inputChar('Y');
    if (choice != 'Y' && choice != 'y') exit(0);
  }
  if (!_engine) _engine = new Engine(indexPath(), IndexParams());
  return *_engine;
}

static void nuke(const MediaGroup& group) {
  engine().db->remove(group);
  QSet<QString> zips;   // ask to delete each zip once
  bool yesAll = false;  // don't ask again
  for (auto& m : qAsConst(group)) {
    QString path = m.path();
    if (m.isArchived()) {
      m.archivePaths(&path);

      if (zips.contains(path)) continue;
      zips.insert(path);

      if (!yesAll) {
        qFlushMessageLog();
        printf("\nnuke: %s\nnuke: zips cannot be modified, trash entire zip? [y/N/a]: ",
               qUtf8Printable(m.path()));
        char ch = inputChar('N');
        if (ch == 'a' || ch == 'A')
          yesAll = true;
        else if (ch != 'Y' && ch != 'y')
          continue;
      }
    }
    if (!DesktopHelper::moveToTrash(path)) exit(-1);
  }
  qInfo() << group.count() << "nuked";
}

void waitFuture(const QFuture<void>& future, const QString& format) {
  auto progress = [&future,&format]() {
    qInfo() << format.arg(future.progressValue()*100/future.progressMaximum());
  };
  while (!future.isFinished()) {
    QThread::msleep(100);
    progress();
  }
  progress();
}

int main(int argc, char** argv) {
  QStringList args(argv, argv+argc);

  if (args.contains("-complete"))
    return printCompletions(argv[0], args);

  if (args.contains("-h") || args.contains("-help") || args.contains("--help"))
    return printUsage(argc, argv);

  (void)qInstallMessageHandler(qColorMessageOutput);

  do {
    const char* logFilter = "*.debug=false";
    if (args.contains("-v") || args.contains("-verbose"))
      break; // use the default filtering (QT_LOGGING_RULES etc)
    if (args.contains("-q") || args.contains("-quiet"))
      logFilter="*.debug=false\n*.info=false\n*.warning=false";
    QLoggingCategory::setFilterRules(logFilter);
  } while(0);

  // if we are pretty sure there is no display connected we can
  // enable headless mode
  bool noDisplay = false;
#if defined(Q_OS_LINUX)
  if (!args.contains("-headless") &&
      !args.contains("-platform") && // qt
      !args.contains("-display") &&  // qt
      getenv("WAYLAND_DISPLAY") == nullptr &&
      getenv("DISPLAY") == nullptr) {
    noDisplay = true;
    qDebug() << "no display detected, use DISPLAY/WAYLAND_DISPLAY/-platform/-display";
  }
#endif

  std::unique_ptr<QCoreApplication> app;
  if (args.contains("-headless") || noDisplay) {
    app.reset(new QCoreApplication(argc, argv));
    qInfo("selected headless mode, gui functions (-show,etc) will abort");
  }
  else {
    auto* guiApp = new QApplication(argc, argv);
    const char* iconPath = ":res/cbird.svg";
#if defined(Q_OS_MAC)
    iconPath=":mac/cbird.icns";
#endif
    guiApp->setWindowIcon(QIcon(iconPath));
    app.reset(guiApp);
  }
  app->setApplicationName(CBIRD_PROGNAME);
  app->setApplicationVersion(CBIRD_VERSION);

  args = app->arguments();  // args after qt strips out its own stuff
  args.removeFirst();


  // remove global args we already handled
  args.removeIf([](const QString& s) {
    static const QSet<QString> loggingArgs{qq("-headless"),
                                           qq("-v"),
                                           qq("-verbose"),
                                           qq("-q"),
                                           qq("-quiet")};
    return loggingArgs.contains(s);
  });

  if (args.count() <= 0) {
    qInfo() << "nothing to do, see -h|-help for usage";
    return 1;
  }

  // always refers to last arg removed from args
  QString arg;

  // FIXME: could this be done lazily? Yes! Put in VideoContext::open()
  VideoContext::loadLibrary();

  // default of 128 sometimes not enough...
  const QString allocLimit = qEnvironmentVariable("QT_IMAGE_ALLOC_LIMIT_MB", "256");
  QImageReader::setAllocationLimit(allocLimit.toInt());

  SearchParams params;
  IndexParams indexParams;
  MediaGroup selection;        // selection of items by properties
  MediaGroupList queryResult;  // results of a search query

  // start cleaning this up...
  Commands _commands(indexParams, params, arg, args, selection, queryResult);

  // set defaults
  indexPath() = ".";
  QString jpegFixPath = "~/bin/jpegfix.sh"; // FIXME: hardcoded configuration

  // show/display options
  int showMode = MediaBrowser::ShowNormal;
  MediaWidgetOptions widgetOptions;

  auto sqlEscapePath = [](const QString& path) {
    return QString(path).replace("%", "\\%").replace("_", "\\_");
  };

  // <selector>
  auto selectPath = [&](const QString& pathSpec) {
    QString path = pathSpec;
    if (path == "@") return selection;

    if (path.startsWith(":")) {
      path = path.mid(1);

      const QRegularExpression re(path);
      if (!re.isValid())
        qFatal("invalid regular expression: %s at offset %lld", qPrintable(re.errorString()),
               re.patternErrorOffset());

      auto selection = engine().db->mediaWithPathRegexp(path);

      qInfo().nospace() << "select {path ~= " << path << "}: " << selection.count() << " items";
      return selection;
    } else {
      QFileInfo info(path);
      if (info.exists()) {
        path = info.absoluteFilePath();
        if (info.isDir() && !path.endsWith(lc('/')))
          path += lc('/'); // if path => "./some" don't select "./something"
      }
      else if (path.contains("/")) {
        // try to form a valid path from the prefix
        QStringList parts = path.split("/");

        QStringList tail;
        tail.append(parts.back());
        parts.pop_back();

        while (parts.count() > 0) {
          const QString cand = parts.join("/");
          const QFileInfo info(cand);
          if (info.exists()) {
            path = info.absoluteFilePath();
            path += "/" + tail.join("/");
            break;
          }
          // last component didn't yield a valid path, it probably contains
          // wildcards
          tail.prepend(parts.back());
          parts.pop_back();
        }
      }

      // make relative to index, required since database stores relative path
      const QString dbPath = engine().db->path();
      if (path.startsWith(dbPath)) path = path.mid(dbPath.length() + 1);

      // trailing wildcard is automatic
      if (!path.endsWith("*")) path.append("*");

      // escape the sql groks, replace sh-style ones
      path = sqlEscapePath(path);
      path = path.replace("\\?", "@question@");
      path = path.replace("\\*", "@asterisk@");
      path = path.replace("?", "_");
      path = path.replace("*", "%");
      path = path.replace("@question@", "?");
      path = path.replace("@asterisk@", "*");

      auto selection = engine().db->mediaWithPathLike(path);

      qInfo().nospace() << "select {path like " << path << "}: " << selection.count() << " items";
      return selection;
    }
    Q_UNREACHABLE();
  };

  //    auto indexRelativePath = [&](const QString& path) {
  //        QString rel = path;
  //        QFileInfo info(rel);
  //        if (info.exists())
  //            rel =
  //            info.absoluteFilePath().mid(engine().db->path().length()+1);
  //        return rel;
  //    };

  auto absolutePath = [](const QString& path) {
    QString abs = path;
    QFileInfo info(abs);
    if (info.exists()) abs = info.absoluteFilePath();
    return abs;
  };

  auto parseType = [](const QString& value) {
    if (value == "i") return int(Media::TypeImage);
    if (value == "v") return int(Media::TypeVideo);
    if (value == "a") return int(Media::TypeAudio);
    return value.toInt();
  };

  auto nextArg = [&]() {
    if (args.count() > 0) return args.takeFirst();
    qCritical() << arg << "requires an argument";
    ::exit(1);
  };

  auto intArg = [&](const QString& str) {
    bool ok;
    int val = str.toInt(&ok);
    if (ok) return val;
    qCritical() << arg << "requires an integer value";
    ::exit(1);
  };

  while (args.count() > 0) {
    arg = args.takeFirst();

#ifdef Q_OS_WIN
    if (arg == "-p" || arg == "-i") {
      // PowerShell splits arguments on ".", put it back together
      if (args.count() > 0 && args.at(0).startsWith(lc('.')))
        arg += args.takeFirst();
      else
        qFatal("-p/-i should be followed by param name and value (-p.dht 3, -i.types i)");
    }
#endif

    if (arg.startsWith("-p.")) {
      const QString val = nextArg();
      const QChar sep = arg[2];
      const QString key = arg.split(sep)[1];
      params.setValue(key, val);
    } else if (arg.startsWith("-i.")) {
      const QString val = nextArg();
      const QChar sep = arg[2];
      const QString key = arg.split(sep)[1];
      indexParams.setValue(key, val);
    } else if (arg == "-list-search-params") {
      MessageContext mc("SearchParams");
      params.print();
    } else if (arg == "-list-index-params") {
      MessageContext mc("IndexParams");
      indexParams.print();
    } else if (arg == "-list-formats") {
      for (auto& mimeType : QImageReader::supportedMimeTypes())
        qInfo().noquote() << mimeType << QImageReader::imageFormatsForMimeType(mimeType);
      VideoContext::listFormats();
    } else if (arg == "-list-codecs") {
      VideoContext::listCodecs();
    } else if (arg == "-use") {
      if (_engine) {
        qCritical("-use: database already open on \"%s\", pass -use before other arguments",
                  qUtf8Printable(_engine->db->path()));
        return -1;
      }
      QString path = nextArg();
      if (path == lc('@')) {
        QDir dir;
        while (!dir.exists(qq(INDEX_DIRNAME))) {
          if (!dir.cdUp()) {
            qCritical("-use[@]: failed to find index in the parent tree");
            return -1;
          }
        }
        path = dir.absolutePath();
      }
      if (!QFileInfo(path).isDir()) {
        qCritical("-use: \"%s\" is not a directory", qUtf8Printable(path));
        return -1;
      }
      indexPath() = path;
    } else if (arg == "-create") {
      checkIndexPathExists = false;
    } else if (arg == "-update") {
      checkIndexPathExists = false;
      int threads = indexParams.indexThreads;
      if (threads <= 0) threads = QThread::idealThreadCount();

      QThreadPool::globalInstance()->setMaxThreadCount(threads);

      Env::setIdleProcessPriority();
      auto& eng = engine();
      eng.scanner->setIndexParams(indexParams);
      eng.update(true);

      QThreadPool::globalInstance()->setMaxThreadCount(QThread::idealThreadCount());

    } else if (arg == "-migrate") {
      Env::setIdleProcessPriority();
      auto& eng = engine();

      MediaGroup media = eng.db->mediaWithType(Media::TypeVideo);
      QString root = eng.db->videoPath();
      VideoIndex::migrate(media, root, indexParams);
    } else if (arg == "-about") {
      Scanner* sc = engine().scanner;
      Database* db = engine().db;
      const QStringList ff = VideoContext::ffVersions();
      const QStringList cv = cvVersion();
      const QStringList ev = Media::exifVersion();
      //            const QStringList qv = {"??", "??"};
      qInfo() << CBIRD_PROGNAME << CBIRD_VERSION << "[" << CBIRD_GITVERSION << "]"
              << CBIRD_HOMEPAGE;
      qInfo() << "build:" << buildFlags();
      qInfo() << "settings:" << DesktopHelper::settingsFile();
      qInfo() << "Qt" << qVersion() << "compiled:" << QT_VERSION_STR;
      qInfo() << "Qt Platform" << qApp->platformName();
      qInfo() << "FFmpeg" << ff[0] << "compiled:" << ff[1];
      qInfo() << "OpenCV" << cv[0] << "compiled:" << cv[1];
      qInfo() << "Exiv2" << ev[0] << "compiled:" << ev[1];
      //            qInfo() << "Quazip" << qv[0] << "compiled:" << qv[1];
      qInfo("max images: %'u", int32_t(INT32_MAX));
      qInfo("max videos: %'u", MAX_VIDEOS_PER_INDEX);
      qInfo("max frames/video: %'u", MAX_FRAMES_PER_VIDEO);

      qInfo() << "threads:" << QThread::idealThreadCount();
      qInfo() << "simpleio:" << SimpleIO::name();

      auto imageExt = sc->imageTypes().values();
      imageExt.sort();
      auto videoExt = sc->videoTypes().values();
      videoExt.sort();
      qInfo() << "image extensions:" << imageExt;
      qInfo() << "video extensions:" << videoExt;
      qInfo() << db->count() << "indexed files";
      qInfo() << db->countType(Media::TypeImage) << "image files";
      qInfo() << db->countType(Media::TypeVideo) << "video files";
      qInfo() << db->countType(Media::TypeAudio) << "audio files";
      qInfo() << "see -license for software license";

    } else if (arg == "-version" || arg == "--version") {
      qInfo() << app->applicationName() << app->applicationVersion() << CBIRD_GITVERSION;
    } else if (arg == "-license" || arg == "--license") {
      printLicense();
#ifndef Q_OS_WIN
    } else if (arg == "-install") {
      QString prefix = "/usr/local";
      if (args.count() > 0) prefix = nextArg();
      install(argv[0], prefix);
#endif
    } else if (arg == "-remove") {
      qInfo() << "removing: " << selection.count() << "items";
      engine().db->remove(selection);
    } else if (arg == "-dups") {
      queryResult = engine().db->dupsByMd5(params);
      qInfo("dups: %lld groups found", queryResult.count());
    } else if (arg == "-dups-in") {
      // dups *within* set ~ similar-in
      SearchParams p = params;
      p.set = selectPath(nextArg());
      p.inSet = true;
      selection.clear();
      queryResult = engine().db->dupsByMd5(p);
      qInfo("dups-in: %lld groups found", queryResult.count());
    } else if (arg == "-nuke-dups-in") {
      // dups *in* directory ~ similar-to
      QString path = nextArg();

      QFileInfo info(path);
      if (!info.isDir() || !info.exists()) qFatal("nuke-dups-in: specified dir does not exist");

      path = info.absoluteFilePath();

      MediaGroupList list = engine().db->dupsByMd5(params);
      MediaGroupList filtered;
      for (const MediaGroup& g : list)
        for (const Media& m : g)
          if (m.path().startsWith(path)) {
            filtered.append(g);
            if (params.verbose) qInfo() << "nuke-dups-in:" << m.path();
            break;
          }

      qInfo() << "nuke-dups-in:" << filtered.count() << "duplicates in" << path;
      if (filtered.count() <= 0) continue;

      qFlushMessageLog();
      printf("nuke-dups-in: %lld items will be trashed, proceed [y/N]: ", filtered.count());
      char ch = inputChar('N');
      if (ch == 'Y' || ch == 'y') {
        int nuked = 0;
        MediaGroup toRemove;
        for (const MediaGroup& group : filtered) {
          // only remove one of the dups; it could be dup of
          // another in the same path
          // -dups-in <dir> -nuke would delete them all
          for (const Media& m : group)
            if (m.path().startsWith(path)) {
              toRemove.append(m);
              break;
            }
        }

        nuke(toRemove);
        qInfo("nuke-dups-in: %d nuked, updating db", nuked);
        engine().db->remove(toRemove);
      }
    } else if (arg == "-nuke-weeds") {
      const auto weeds = engine().db->weeds();
      if (weeds.count() <= 0) {
        qInfo("nuke-weeds: no weeds found");
        continue;
      }

      MediaGroup toRemove;
      for (auto& g : weeds) {
        Q_ASSERT(g.count() == 2);
        auto& w = g[1];
        Q_ASSERT(engine().db->isWeed(w));
        if (params.verbose) qInfo() << "nuke-weeds:" << w.path();
        toRemove.append(w);
      }
      qFlushMessageLog();
      printf("\nnuke-weeds: %lld items will be trashed, proceed [y/N]: ", toRemove.count());
      char ch = inputChar('N');
      if (ch == 'Y' || ch == 'y') {
        nuke(toRemove);
        qInfo("nuke-weeds: %lld nuked, updating db", weeds.count());
        engine().db->remove(toRemove);
      }
    } else if (arg == "-nuke") {
      if (selection.count() > 0) {
        qFlushMessageLog();
        printf("\nnuke: about to move %lld items to trash, proceed? [y/N]: ", selection.count());
        char ch = inputChar('N');
        if (ch == 'Y' || ch == 'y') {
          nuke(selection);
          selection.clear();
        }
      } else
        qInfo() << "-nuke: nothing selected";
    } else if (arg == "-similar") {
      queryResult = engine().db->similar(params);
    } else if (arg == "-similar-in") {
      params.set = selectPath(nextArg());
      params.inSet = true;
      selection.clear();
      queryResult = engine().db->similar(params);
      qInfo() << "similar-in: " << queryResult.count() << "result(s)";
    } else if (arg == "-similar-to") {
      const QString to = nextArg();
      const QFileInfo info(to);

      queryResult.clear();
      MediaGroupList list;

      Scanner* scanner = engine().scanner;

      const QString ext = info.suffix();
      const bool isFile = info.isFile();
      const bool isArchive = scanner->archiveTypes().contains(ext);
      const bool isImage = scanner->imageTypes().contains(ext);
      const bool isVideo = scanner->videoTypes().contains(ext);
      const bool isHash = to.startsWith("dct:");

      MediaGroup needles = selectPath(to);

      if (needles.isEmpty()) {
        if ((isFile | isHash) && !isArchive) {
          MessageContext ctx(to);
          if (isHash
              && (params.algo == SearchParams::AlgoDCT || params.algo == SearchParams::AlgoVideo)) {
            bool ok;
            uint64_t hash = to.split(":").back().toULongLong(&ok, 16);
            if (!ok) {
              qWarning() << "similar-to: invalid hash, expected 64-bit hex";
              continue;
            }
            needles += Media("@" + to, Media::TypeImage, -1, -1, "", hash);
          } else if (isImage && params.queryTypes & SearchParams::FlagImage) {
            needles += Media(QDir().absoluteFilePath(to));
          } else if (isVideo && params.queryTypes & SearchParams::FlagVideo) {
            qWarning() << "similar-to: no video index, grabbing some frames";
            QList<QFuture<Media>> work;

            IndexParams tmp = indexParams;
            tmp.retainImage = true;
            tmp.autocrop = true;
            tmp.algos = 1 << SearchParams::AlgoDCT;

            scanner->setIndexParams(tmp);

            int numFrames;
            VideoContext::Metadata meta;
            {
              VideoContext v;
              if (0 != v.open(to)) {
                qCritical() << "similar-to: failed to open video";
                continue;
              }

              meta = v.metadata();
              numFrames = int(meta.frameRate * meta.duration);
              if (numFrames <= 0) {
                qCritical() << "similar-to: no frames/invalid frame count";
                continue;
              }
            }

            // grab at 10%,20%...90% position
            for (int i = 1; i < 10; i++) {
              int pos = int(numFrames * (i * 0.10));

              work.append(QtConcurrent::run([=] {
                QImage img = VideoContext::frameGrab(to, pos, true);
                if (img.isNull())
                  return Media();

                img = img.convertToFormat(QImage::Format_RGB32); // MGLW needs this

                Media m(to, Media::TypeImage, img.width(), img.height());
                m.setImage(img);
                m.setMatchRange(MatchRange(-1, pos, 1));      // range.dstIn is the needle's pos
                m.setAttribute("grab", QString::number(pos)); // to fix needle after search

                return m;
              }));
            }

            for (auto& w : work) {
              w.waitForFinished();

              Media grabbed = w.result();
              if (grabbed.image().isNull())
                continue;

              meta.toMediaAttributes(grabbed);

              needles += grabbed;
            }

            scanner->setIndexParams(indexParams); // restore

          } else {
            qWarning("similar-to: invalid filetype for algo or unsupported filetype");
            if (isVideo)
              qInfo("similar-to: for video search, use -p.alg video");

            continue;
          }
        } else {
          // select path as if -select-file was used
          // FIXME: if path contains videos they won't be frame grabbed
          args.prepend(to);
          selection = _commands.selectFiles();
          needles = selection;
        }
      } // special inputs

      if (needles.isEmpty())
        qWarning() << "similar-to: empty selection, is" << to << "a valid path or selector?";

      MediaSearch search;
      search.params = params;

      // this not the same as similar-in... which is a subset query
      QList<QFuture<MediaSearch>> work;
      for (const Media& m : needles)
        if (search.params.mediaSupported(m)) {
          search.needle = m;
          work.append(QtConcurrent::run(&Engine::query, &engine(), search));
        }

      PROGRESS_LOGGER(pl, "similar-to:<PL> %percent %bignum lookups, %1 results", work.count());
      pl.showLast();

      int i = 1;
      for (auto& w : work) {
        try { // FIXME: what is throwing exceptions? engine::query does not throw
          w.waitForFinished();
        } catch (std::exception& e) {
          qCritical("exception: %s", e.what());
          w.waitForFinished();
        }

        search = w.result();

        // if needle is a frame grab we want to display as a video
        // even though it is an image
        if (search.needle.attributes().contains("grab"))
          search.needle.setType(Media::TypeVideo);

        // note: engine.query(db.similarTo) already filtered matches,
        // but we still need to filter the whole list, which
        // requires the needle in the first position
        if (search.matches.count() > 0) {
          search.matches.prepend(search.needle);
          list.append(search.matches);
        }

        if (++i % 10 == 0)
          pl.step(i, {list.count()});
      }
      engine().db->filterMatches(params, list);

      Media::sortGroupList(list, {"path"});

      selection.clear();
      queryResult = list;
      pl.end(0, {queryResult.count()});
    } else if (arg == "-weeds") {
      selection.clear();
      queryResult = engine().db->weeds();
      qInfo() << "weeds:" << queryResult.count() << "result(s)";
    } else if (arg == "-select-none") {
      selection.clear();
    } else if (arg == "-select-all") {
      selection.append(engine().db->mediaWithSql("select * from media"));
    } else if (arg == "-select-id") {
      int id = intArg(nextArg());
      Media m = engine().db->mediaWithId(id);
      if (!m.isValid())
        qWarning("select-id: nothing found");
      else
        selection.append(m);
    } else if (arg == "-select-one") {
      Media m = engine().db->mediaWithPath(nextArg());
      if (!m.isValid())
        qWarning("select-one: nothing with that path");
      else
        selection.append(m);
    } else if (arg == "-select-type") {
      int type = parseType(nextArg());
      selection.append(engine().db->mediaWithType(type));
    } else if (arg == "-select-path") {
      selection.append(selectPath(nextArg()));
    } else if (arg == "-select-errors") {
      QMutexLocker locker(Scanner::staticMutex());
      const auto errors = Scanner::errors();
      for (auto it = errors->begin(); it != errors->end(); ++it)
        if (!it.value().contains(Scanner::ErrorUnsupported)) {
          QString path = it.key();
          selection.append(Media(path));
        }
    } else if (arg == "-select-result") {
      for (auto& g : queryResult) selection.append(g);
      // pretend it is sorted to prevent re-sort in -show
      if (!selection.empty()) selection.first().setAttribute("sort", "(select-result)");
      queryResult.clear();
    } else if (arg == "-select-sql") {
      selection.append(engine().db->mediaWithSql(nextArg()));
    } else if (arg == "-select-files") {
      if (args.count() < 1) qFatal("-select-files expects one or more arguments");
      selection.append(_commands.selectFiles());
    } else if (arg == "-select-grid") {
      const MediaGroup fileList = _commands.selectFiles();
      for (const Media& grid : fileList) {
        MessageContext ctx(grid.path());

        QImage qImg = grid.loadImage();
        cv::Mat cvImg;
        QVector<QRect> rects;

        qImageToCvImg(qImg, cvImg);
        demosaic(cvImg, rects);

        int i = 1;
        for (const QRect& r : rects) {
          QString path = grid.path() + "@rect" + QString::number(i++);
          Media m(path, Media::TypeImage, r.width(), r.height());
          m.setImage(qImg.copy(r));
          m.setIsFile(false);
          selection.append(m);
        }
      };
    } else if (arg == "-slice") {
      params.set = selectPath(nextArg());
      params.inSet = true;
    } else if (arg == "-rename") {
      QString srcPat, dstPat, options;
      srcPat = nextArg();
      dstPat = nextArg();
      if (args.count() > 0) options = args.takeFirst();
      if (srcPat == "*") srcPat = "^.*$";
      _commands.rename(engine().db, srcPat, dstPat, options);
    } else if (arg == "-move") {
      const QString dstDir = absolutePath(nextArg());
      qInfo() << "moving " << selection.count() << "items to:" << dstDir;
      MediaGroup moveable;
      QStringList movedZips;
      for (auto& m : selection) {
        if (!m.isArchived()) {
          moveable.append(m);
          continue;
        }

        QString zipPath;
        m.archivePaths(&zipPath);
        if (movedZips.contains(zipPath)) continue;

        const QFileInfo info(zipPath);
        const QString newZipPath = dstDir + lc('/') + info.fileName();
        qDebug() << "move zip" << zipPath << "=>" << newZipPath;
        if (!engine().db->moveDir(zipPath, newZipPath)) return -2;
        movedZips.append(zipPath);
      }
      for (auto& m : moveable)
        (void)engine().db->move(m, dstDir);

      selection.clear();
    } else if (arg == "-with" || arg == "-without") {
      std::vector<Commands::Filter> filters;
      filters.push_back({nextArg(), nextArg(), arg == "-without"});
      while (args.count() > 0) {
        auto& peekArg = args.at(0);
        if (peekArg != "-or-with" && peekArg != "-or-without") break;
        arg = nextArg();
        bool without = arg == "-or-without";
        filters.push_back({nextArg(), nextArg(), without});
      }
      _commands.filter(filters);
    } else if (arg == "-or-with" || arg == "-or-without") {
      qFatal("-or-with / -or-without must be preceded by -with");
    } else if (arg == "-first") {
      for (auto& g : queryResult)
        if (g.count() > 0) g = {g[0]};
      if (selection.count() > 0) selection = {selection[0]};
    } else if (arg == "-chop") {
      for (auto& g : queryResult)
        if (g.count() > 0) g.removeFirst();
      if (selection.count() > 0) selection.removeFirst();
    } else if (arg == "-head") {
      int n = intArg(nextArg());
      if (n <= 0) qFatal("count must be > 0");
      auto f = [n](MediaGroup& g) {
        if (g.count() > n) g.resize(n);
      };
      for (auto& g : queryResult) f(g);
      f(selection);
    } else if (arg == "-tail") {
      int n = intArg(nextArg());
      if (n <= 0) qFatal("count must be > 0");
      auto f = [n](MediaGroup& g) {
        if (g.count() > n) g = g.mid(g.count() - n);
      };
      for (auto& g : queryResult) f(g);
      f(selection);
    } else if (arg == "-first-sibling") {
      auto fn = [=](MediaGroup& g) {
        QSet<QString> parents;
        MediaGroup filtered;
        for (auto& m : g) {
          auto p = m.dirPath();
          if (parents.contains(p)) continue;
          filtered.append(m);
          parents.insert(p);
        }
        return filtered;
      };

      if (queryResult.count() > 0)
        for (auto& g : queryResult) g = fn(g);
      if (selection.count() > 0)
        selection = fn(selection);
    } else if (arg.startsWith("-sort") && arg != "-sort-similar") {
      const QChar invertPrefix = lc('^');
      QStringList keys;

      // -sort,-sort-rev,-sort-result,-sort-result-rev
      bool sortGroupList = false;
      QStringList validCmds = {"-sort","-sort-rev"};
      if (arg.mid(5,7)=="-result") {
        validCmds = {"-sort-result","-sort-result-rev"};
        sortGroupList = true;
      }

      if (!validCmds.contains(arg)) {
        qFatal("invalid argument, expected %s", qUtf8Printable(validCmds.join(" or ")));
        continue;
      }

      auto key = nextArg();
      if (arg.endsWith("-rev")) key = invertPrefix+key;
      keys.append(key);

      while (args.count() > 0) {
        auto& peekArg = args.at(0);
        if (!validCmds.contains(peekArg)) break;
        arg = nextArg();
        key = nextArg();
        if (arg.endsWith("-rev")) key = invertPrefix+key;
        keys.append(key);
      }

      if (sortGroupList && queryResult.count() <= 0) {
        qWarning("sort-result: empty result");
        continue;
      }

      // some properties are slow, pre-compute them
      QVector<Media*> mediaPtr;
      if (queryResult.count() > 0) {
        for (auto& g : queryResult)
          for (auto& m : g) {
            mediaPtr += &m;
            if (sortGroupList) break; // sortGroupList sorts by first item
          }
      }
      else
        for (auto& m : selection)
          mediaPtr += &m;

      if (mediaPtr.count() <= 0) {
        qWarning("sort: empty selection/result");
        continue;
      }

      bool external = false;
      for (auto prop: keys) {
        if (prop.startsWith(invertPrefix)) prop = prop.mid(1);
        external |= Media::isExternalProperty(prop);

        QAtomicInt nonNull = 0;
        auto getValue = Media::propertyFunc(prop);
        auto future = QtConcurrent::map(mediaPtr, [&getValue, &nonNull](Media* m) {
          if (!getValue(*m).isNull()) nonNull.fetchAndAddRelaxed(1);
        });
        PROGRESS_LOGGER(pl,
                        qq("sort: collecting {%1}<PL> %percent %bignum lookups, %2 values").arg(prop).arg("%1"),
                        future.progressMaximum());
        while (!future.isFinished()) {
          QThread::msleep(100);
          pl.step(future.progressValue(), {nonNull.loadRelaxed()});
        }
        pl.end(0, {nonNull.loadRelaxed()});
      }
      if (external) {
        auto future = QtConcurrent::map(mediaPtr, [](Media* m) {
          m->readMetadata();
        });
        PROGRESS_LOGGER(pl, "sort: read metadata<PL> %percent %bignum files", future.progressMaximum());
        while (!future.isFinished()) {
          QThread::msleep(100);
          pl.step(future.progressValue());
        }
        pl.end();
      }

      if (queryResult.count() > 0) {
        if (sortGroupList)
          Media::sortGroupList(queryResult, keys);
        else
          Media::sortGroups(queryResult, keys);
      }
      else {
        Media::sortGroup(selection, keys);
        for (auto& m : selection) m.setAttribute("sort", "yes");
      }
    } else if (arg == "-group-by") {
      const QString expr = nextArg();
      queryResult = Media::groupBy(selection, expr);
      qInfo("group-by: { %s } %lld groups from %lld items", qUtf8Printable(expr),
            queryResult.count(), selection.count());
      selection.clear();
    } else if (arg == "-sort-similar") {
      MediaGroup sorted;
      SearchParams sp = params;
      sp.set = selection;
      sp.inSet = true;
      // sp.maxMatches = 2;

      const int lookBehind = 5;
      Q_ASSERT(selection.count() > 0);

      QMap<QString, Media> unsorted;

      for (auto& m : selection) unsorted.insert(m.path(), m);

      sorted.append(selection.front());
      unsorted.remove(selection.front().path());

      // TODO: use merge sort; each partition can be threaded
      PROGRESS_LOGGER(pl, "sort-similar:<PL> %percent %1 queries, %2 not found", selection.count()-1);

      int queries = 0, notFound = 0;
      for (int i = 0; i < selection.count() - 1; ++i) {
        // search won't necessarily find anything,
        // improve chances by looking behind
        for (int j = 0; j < qMin(lookBehind, sorted.count()); ++j) {
          MediaSearch search;
          search.params = sp;
          //search.params.cvThresh = search.params.dctThresh = INT_MAX;
          //search.params.maxMatches = 1;
          search.needle = sorted[sorted.count() - 1 - j];

          // set must also contain needle or else we can't search for it
          MediaGroup querySet = unsorted.values().toVector();
          querySet.append(search.needle);

          search.params.set = querySet;  // subset query
          search.params.inSet = true;

          search = engine().query(search);

          if (search.matches.count() > 0) {
            Media& match = search.matches[0];
            sorted.insert(sorted.count() - j, match);
            unsorted.remove(match.path());
          }
          else
            notFound++;

          if (++queries % 100 == 0) pl.step(i, {queries, notFound});
        }
      }
      pl.end(0, {queries, notFound});

      if (notFound)
        qWarning() << "sort-similar: " << notFound
                   << " items were not found and could not be sorted, try fuzzier search params";
      selection = sorted;
      for (auto& m : selection) m.setAttribute("sort", "similar");

    } else if (arg == "-merge") {
      MediaGroup setA = selectPath(nextArg());
      MediaGroup setB = selectPath(nextArg());

      // TODO: generalized multisearch
      auto multiSearch = [](const Media& needle, const SearchParams& params) {
        MediaSearch search;
        search.params = params;
        search.needle = needle;
        search.params.maxMatches = 2;

        // if match.score is >= threshold, use the next algorithm
        int thresholds[] = {
            12,
            1000,
            1000,
            INT_MAX,
        };

        bool ok = false;
        do {
          search = engine().query(search);
          // engine().db->filterMatch(params, search.matches);

          ok = search.matches.count() > 0;
          ok = ok && search.matches[0].score() < thresholds[search.params.algo];

          if (!ok) search.params.algo++;
          if (search.params.algo > 3) break;
        } while (!ok);
        if (!ok) search.matches.clear();

        return search;
      };

      QVector<QFuture<MediaSearch>> work;

      SearchParams multiParams = params;
      multiParams.set = setA;
      multiParams.inSet = true;

      for (const auto& b : setB) {
        multiParams.set.append(b);
        work.append(QtConcurrent::run(multiSearch, b, multiParams));
      }

      for (auto& wi : work) {
        wi.waitForFinished();
        MediaSearch search = wi.result();
        if (search.matches.count() <= 0) {
          qCritical() << "no match:" << search.needle.path();
          continue;
        }

        // search.matches.prepend(search.needle);
        // MediaBrowser::show({search.matches}, params);

        int pos = Media::indexInGroupByPath(setA, search.matches.at(0).path());
        Q_ASSERT(pos >= 0 && pos < setA.length());

        // we found the closest match, should it go before or after?
        if (pos > 0 && pos < setA.length() - 1) {
          int before = hamm64(search.needle.dctHash(), setA[pos - 1].dctHash());
          int after = hamm64(search.needle.dctHash(), setA[pos + 1].dctHash());

          if (after < before) pos++;
        }
        setA.insert(pos, search.needle);
      }
      selection = setA;
      for (auto& m : selection) m.setAttribute("sort", "merged");

    } else if (arg == "-dump") {
      Media::printGroupList(queryResult);
      Media::printGroup(selection);
    } else if (arg == "-sets") {
      showMode = MediaBrowser::ShowPairs;
    } else if (arg == "-folders") {
      showMode = MediaBrowser::ShowFolders;
    } else if (arg == "-exit-on-select") {
      widgetOptions.selectionMode = MediaWidgetOptions::SelectExitCode;
    } else if (arg == "-max-per-page") {
      widgetOptions.maxPerPage = intArg(nextArg());
    } else if (arg == "-focus-first") {
      widgetOptions.flags |= MediaWidgetOptions::FlagSelectFirst;
    } else if (arg == "-no-delete") {
      widgetOptions.flags |= MediaWidgetOptions::FlagDisableDelete;
    } else if (arg == "-theme") {
      Theme::setDefaultStyle(nextArg());
    } else if (arg == "-show") {
      widgetOptions.params = params;
      widgetOptions.db = _engine ? _engine->db : nullptr;  // should not require db (-select-files)
      if (!queryResult.isEmpty())
        MediaBrowser::show(queryResult, showMode, widgetOptions);
      else {
        // sort by folder/archive if no sort was given
        if (selection.count() && !selection.first().attributes().contains("sort"))
          Media::sortGroup(selection, {"path"});

        auto getProp = Media::propertyFunc("parentPath");

        qDebug("make groups of %d", widgetOptions.maxPerPage);
        MediaGroupList list;
        MediaGroup group;
        QString groupKey = selection.count() > 0 ? getProp(selection[0]).toString() : QString();
        for (const Media& m : selection) {
          bool closeGroup = false;

          // split on parent path if using folder view
          // show each video as a separate thumbnail
          if (showMode == MediaBrowser::ShowFolders) {
            auto key = getProp(m).toString();
            if (groupKey == key && m.type() != Media::TypeVideo)
              group.append(m);
            else {
              closeGroup = true;
              groupKey = key;
            }
          } else
            group.append(m);

          if (group.count() >= widgetOptions.maxPerPage || closeGroup) {
            if (group.count() > 0) list.append(group);
            group.clear();
            if (closeGroup) group.append(m);
          }
        }

        if (group.count() > 0) list.append(group);

        int pos = 0;
        for (auto& g : list)
          for (auto& m : g) m.setPosition(pos++);

        qDebug("show browser: mode=%d groups=%lld", showMode, list.count());
        int status = MediaBrowser::show(list, showMode, widgetOptions);
        if (widgetOptions.selectionMode == MediaWidgetOptions::SelectExitCode) return status - 1;
      }
    } else if (arg == "-qualityscore") {
      IndexResult result = engine().scanner->processImageFile(nextArg());
      if (result.ok) {
        QVector<QImage> visuals;
        qualityScore(result.media, &visuals);
        // selection.append(result.media);
        queryResult.append({result.media});
        for (auto& img : visuals) {
          Media m(img);
          m.setPath(img.text("description"));
          // selection.append(m);
          queryResult.append({m});
        }
      }
#ifdef DEPRECATED
    } else if (arg == "-updatemd5") {
      // deprecated: for old indexes that stored sparse md5, update to full md5
      for (const Media& m : selection) {
        Q_ASSERT(m.type() == Media::TypeVideo);
        {
          QFile f(m.path());
          if (!f.open(QFile::ReadOnly)) qFatal("failed to open: %s", qUtf8Printable(m.path()));
          if (m.md5() != sparseMd5(f)) {
            qCritical() << "updateMd5: no update since hash could be the new version" << m.path()
                        << m.md5();
            continue;
          }
        }
        QString hash = Scanner::hash(m.path(), m.type());
        Media copy = m;
        if (!engine().db->setMd5(copy, hash) || copy.md5() != hash) return -1;
        qInfo() << "updateMd5" << m.path() << m.md5() << hash;
      }
#endif
    } else if (arg == "-jpeg-repair-script") {
      jpegFixPath = nextArg();
    } else if (arg == "-verify") {
      _commands.verify(engine().db, jpegFixPath); // TODO: move to database
    } else if (arg == "-test-csv") {
      _commands.testCsv(engine(), nextArg());
    } else if (arg == "-vacuum") {
      engine().db->vacuum();
    } else if (arg == "-test-add-video") {
      IndexResult result = engine().scanner->processVideoFile(nextArg());
      MediaGroup media{result.media};
      if (result.ok) engine().db->add(media);
    } else if (arg == "-compare-videos") {
      Media left(nextArg(), Media::TypeVideo);
      Media right = left;
      if (args.count() > 0) right = Media(nextArg(), Media::TypeVideo);
      Theme::setup();
      VideoCompareWidget v(left, right);
      v.show();
      v.activateWindow();
      app->exec();
    } else if (arg == "-video-thumbnail") {
      QString path = nextArg();
      Media m = engine().db->mediaWithPath(path);
      if (!m.isValid()) {
        qWarning() << m.path() << "is not in the database, metadata will not be saved";
        m = Media(path, Media::TypeVideo);
      }
      int frame = nextArg().toInt();
      m.setImage(VideoContext::frameGrab(m.path(), frame, false));
      m.setMatchRange({-1, frame, 1});
      CropWidget::setIndexThumbnail(*engine().db, m);
    } else if (arg == "-test-image-loader") {
      ImageLoadOptions options;
      options.fastJpegIdct = true;
      options.readScaled = true;
      options.minSize = indexParams.resizeLongestSide;
      options.maxSize = indexParams.resizeLongestSide * 1.5;
      selection.front().loadImage();
      selection.pop_front();

      qint64 then = QDateTime::currentMSecsSinceEpoch();
      for (auto& m : selection) {
        auto io = m.ioDevice();
        Q_ASSERT(io->open(QIODevice::ReadOnly));
        QImage img = m.loadImage(io->readAll(), QSize(), "", nullptr, options);
        delete io;
        qDebug() << img.text(Media::ImgKey_FileWidth) << "=>" << img.width() << img.format();
      }
      qint64 now = QDateTime::currentMSecsSinceEpoch();
      qInfo() << (now - then) / selection.count() << "ms/image";
    } else if (arg == "-test-image-search") {
      _commands.testImageSearch(engine());
    } else if (arg == "-test-video-decoder") {
      const QString path = nextArg();
      _commands.testVideoDecoder(path);
    } else if (arg == "-test-video") {
      _commands.testVideoIndex(engine(), nextArg());
    } else if (arg == "-test-update") {
      _commands.testUpdate(engine());
    } else {
      qCritical("invalid argument=%s", qUtf8Printable(arg));
#ifdef Q_OS_WIN
      if (arg == "-p" || arg == "-i") qWarning() << "in PowerShell you must use -p: / -i: ";
#endif
      return 1;
    }
  }

  return 0;
}
